#+BEGIN_COMMENT
.. title: Don't release to Production, release to QA
.. slug: release-to-qa-not-production
.. date: 2022-05-30 15:55:25 UTC+03:00
.. tags:
.. category:
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT

  *Automate your release workflow to such extent that the QA engineers from your team become the users of the application.*

* Introduction

  Have you ever been in this situation/Is this picture ringing any bells?
  Friday afternoon, at the end of the sprint, a few hours before the weekend starts, the last Product Backlog Item (PBI) is in QA and you get a notification --- there is an issue with the application.
  After discussing with the person responsible for testing the PBI you find out that the issue is due to some leftover data from the previous sprint/PBI.
  You spend a few minutes to craft an SQL script that will clean the data, send it to the colleague responsible for QA, he/she runs it and then confirms that the application is "back to normal".
  You both sigh in relief while the PBI is marked as "Done" and the weekend starts. Bliss!

* A closer look on the application environments                    :noexport:

  A rather traditional flow in the application life-cycle management is its journey through the so-called [[https://en.wikipedia.org/wiki/Development,_testing,_acceptance_and_production][DTAP environments]] (Development, Testing, Acceptance, and Production) --- a list of successive environments where each environment is subject to more restrictions than the previous one.

  Let's briefly glance over those environments and discuss this journey.

  +Let's briefly discuss the traditional DTAP setup from the application life-cycle management:+
  +- Development --- dirty+
  +- Testing+
  +- Acceptance+
  +- Production --- the Valhalla; where each feature of each application wants to get.+

** Development environment

   At the beginning there is the development environment. As with any other place where creation process is at home, this is an environment where instability abounds because there is always something in motion --- multiple developers trying to quickly validate some of the work they've done in order to be able to move forward make multiple deployments a day with features that are in progress, and after each deployment they usually fiddle with either the database or the configuration in order to get a glimpse of whether what they're working on is doing what it should do and if not then /why/ it isn't doing so.

   As such, there is no wonder that this environment is called dirty --- there is no guarantee that if something works now it won't break in the upcoming 5 minutes.

** Testing/QA environment

   Although there are hard boundaries between each environment, the Testing environment is not that stable either, and furthermore, some of the dirtiness from the Development environment manages to cross the boundary into Testing. This dirtiness is the topic of this article.

   In an ideal world, each new feature or bug fix is deployed and tested on its own in the Testing environment. In the real world, the QA team prefers to bundle a set of features together, deploy them to the Testing environment and start hunting for bugs.

   An important aspect: whenever a bug is found, the person that found it has to spend more time in order to try to identify its root cause (why this is happening) --- is it a configuration issue, is it because the implementation is lacking some corner-case coverage, or is it other factor?

* The problem

  Although you did save the day and the sprint goal, I would argue that what you did was to fix the issue but not remove the root cause, and by not removing the root cause you perpetuate the practice of applying workarounds instead of fixing things. A consequence of this practice, as I will try to prove in the following sections, is that the evolution of the application you're working on is hindered, and this impediment affects none others than those for whom you're building the application --- its users.

  The database issue stems from the fact that instead of being kept as close as possible to production data the database grew to become an entity of its own through not being kept tidy by the team. Usually, testing a PBI involves affecting the data from the database.

  So, the goal here should be that the database is kept as close as possible to the production data; however  the paradox is that the cleanup script, although it solves the issue, is /yet another change to the data/ which doesn't actually bring the QA database closer to the production data.

  At this point you may argue that the solution would be to restore the database from a backup which will make it as close to production data as it ever was.

  Yes, this is the solution but it is incomplete, and here's why: as with the database straying farther away from the production data with each operation applied to the data within (which is OK for testing purposes), the same goes for the QA engineer who by having to tap into the database to find answers for the problem at hand, strays further away from the real users of the application. And this brings me to the main point of this article.

* The QA engineer should be the user of the application

  The main role of a QA engineer is to ensure that the application being tested satisfies the needs of its users. As such, the QA engineer needs to think like a user, and to act like a user. In other words, to be able to do his job, a QA engineer has to be able to (quickly) shift back and forth from the mindset of the problem analyst required by the job description, to the mindset of the application user.

  How to do this? Treat the QA like a user, and enable him/her to do so by alleviating the burden of the plethora of tasks that he/she must do before shifting into the user mindset. And now we move onto how to remove that burden.

* Automation is key

  To alleviate the difference between successive environments you only need to do one thing, although I must say from the start that achieving that one thing /can be really hard/ --- *automate everything*.

  If a release workflow is properly (read /fully/) automated, then the difference between various environments is reduced mainly to one thing --- the group of people who have proper access rights to run the workflow on the specific environment. With today's' tools on the market the difference becomes simplified further --- it is in the group of people that are allowed to see or to push the "Deploy" button.

* Tight feedback loop


* The Snowball Effect

  One great thing about having a small/tight feedback loop as the one you can get when QA environment is treated as production is that it starts a [[https://en.wikipedia.org/wiki/Snowball_effect][snowball effect]] where, as mentioned before, automation is key.

  At first, you gain efficiency --- there is no checklist to go through when deploying, no time needed to spend doing the tedious steps of deployment; the computers will perform those steps as quickly as possible and /always/ in the same order without skipping any of them or making the errors that humans usually do when performing tedious work. With a click of a button, or on a certain event the deployment starts and while it runs the people from the team are free to do whatever they want in the time it takes to deploy: they can have a cup of coffee, can make small talk with a colleague, or can mind the more important business like the overall quality of the product they're working on.
  Furthermore, besides efficiency you can gain speed --- just by delegating the deployment process to computers you can gain some --- computers do tedious things faster.

  With efficiency and speed comes a reduced what Martin Fowler calls [[https://martinfowler.com/articles/branching-patterns.html#integration-friction][integration friction]].

  Less integration friction means higher integration frequency, more deployments which make the QA engineers work more with the app they're testing. And this is where the magic unravels.

* Conclusion

  Having to see your colleague from QA as a user of the application (and thus whose word weighs a lot in the discussions about the application) is strange. After all, you both know a lot more of what's under the hood of the application for any of you to be considered a simple user of it.

  But if you take from the QA engineer all the hassle of deployment and fiddling with making the application run properly in the testing environment you are freeing his/her time for working with the application just enough time to shift his/her mindset into the mindset of an actual user, and having a user of the application close by is a treasure trove for building the application in such a way that it accomplishes its purpose --- catering to users' needs.

  And, as the saying goes, to change the world you need to start with changing yourself. This change comes when you treat QA environment as production environment and make all the efforts needed to uphold the delivery to QA to the same rigor as delivery to production. In essence, it's nothing but a shift in the mindset that was already mentioned in the title --- don't release to Production, release to QA.
